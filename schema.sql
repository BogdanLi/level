-- Custom types
create type public.app_permission as enum (
  'dictionaries',
  'notes',
  'projects',
  'verses.set',
  'moderator.set',
  'user_projects',
  'project_source',
  'coordinator.set',
  'languages',
  'user_languages'
);
create type public.app_role as enum (
  'admin',
  'coordinator',
  'moderator',
  'translator'
);
create type public.project_type as enum ('obs', 'bible');
create type public.book_code as enum (
  'gen',
  'exo',
  'lev',
  'num',
  'deu',
  'jos',
  'jdg',
  'rut',
  '1sa',
  '2sa',
  '1ki',
  '2ki',
  '1ch',
  '2ch',
  'ezr',
  'neh',
  'est',
  'job',
  'psa',
  'pro',
  'ecc',
  'sng',
  'isa',
  'jer',
  'lam',
  'ezk',
  'dan',
  'hos',
  'jol',
  'amo',
  'oba',
  'jon',
  'mic',
  'nam',
  'hab',
  'zep',
  'hag',
  'zec',
  'mal',
  'mat',
  'mrk',
  'luk',
  'jhn',
  'act',
  'rom',
  '1co',
  '2co',
  'gal',
  'eph',
  'php',
  'col',
  '1th',
  '2th',
  '1ti',
  '2ti',
  'tit',
  'phm',
  'heb',
  'jas',
  '1pe',
  '2pe',
  '1jn',
  '2jn',
  '3jn',
  'jud',
  'rev',
  'obs'
);
-- USERS
create table public.users (
  id uuid not null primary key,
  -- UUID from auth.users
  email text not null unique,
  agreement boolean not null default false,
  confession boolean not null default false,
  blocked timestamp default null
);
-- USER ROLES
create table public.user_roles (
  id bigint generated by default as identity primary key,
  user_id uuid references public.users on delete cascade not null,
  role app_role not null,
  unique (user_id, role)
);
comment on table public.user_roles is 'Application roles for each user.';
-- ROLE PERMISSIONS
create table public.role_permissions (
  id bigint generated by default as identity primary key,
  role app_role not null,
  permission app_permission not null,
  unique (role, permission)
);
comment on table public.role_permissions is 'Application permissions for each role.';
-- LANGUAGES
create table public.languages (
  id bigint generated by default as identity primary key,
  eng text not null,
  code text not null unique,
  orig_name text not null,
  is_GL boolean not null default false
);
-- METHODS
create table public.methods (
  id bigint generated by default as identity primary key,
  name text not null
);
-- PROJECTS
create table public.projects (
  id bigint generated by default as identity primary key,
  name text not null,
  code text not null,
  language_id bigint references public.languages on delete restrict not null,
  method_id bigint references public.methods on delete restrict not null,
  type project_type not null,
  unique (code, language_id)
);
-- PROJECT COORDINATORS
create table public.project_coordinators (
  id bigint generated by default as identity primary key,
  project_id bigint references public.projects on delete cascade not null,
  user_id uuid references public.users on delete restrict not null,
  unique (project_id, user_id)
);
-- PROJECT MODERATORS
create table public.project_moderators (
  id bigint generated by default as identity primary key,
  project_id bigint references public.projects on delete cascade not null,
  user_id uuid references public.users on delete restrict not null,
  unique (project_id, user_id)
);
-- PROJECT TRANSLATORS
create table public.project_translators (
  id bigint generated by default as identity primary key,
  project_id bigint references public.projects on delete cascade not null,
  user_id uuid references public.users on delete restrict not null,
  unique (project_id, user_id)
);
-- BRIEFS
create table public.briefs (
  id bigint generated by default as identity primary key,
  project_id bigint references public.projects on delete cascade not null UNIQUE,
  text text not null
);
-- STEPS
create table public.steps (
  id bigint generated by default as identity primary key,
  name text not null,
  method_id bigint REFERENCES public.methods on delete cascade not null,
  config jsonb not null,
  order int2 not null,
  unique (method, order)
);
-- BOOKS
create table public.books (
  id bigint generated by default as identity primary key,
  code book_code not null,
  project_id bigint references public.projects on delete cascade not null,
  text text default null,
  unique (project_id, code)
);
comment on table public.books is 'Подумать о том, что будет если удалить проект. Так как в таблице книги мы хотим хранить текст';
-- CHAPTERS
create table public.chapters (
  id bigint generated by default as identity primary key,
  number int2 not null,
  book_id bigint REFERENCES public.books on delete cascade not null,
  text text default null,
  unique (book_id, number)
);
-- VERSES
create table public.verses (
  id bigint generated by default as identity primary key,
  number int2 not null,
  chapter_id bigint REFERENCES public.chapters on delete cascade not null,
  project_translator_id bigint REFERENCES public.project_translators on delete restrict not null,
  unique (chapter_id, number)
);
-- PROGRESS
create table public.progress (
  id bigint generated by default as identity primary key,
  verse_id bigint REFERENCES public.verses on delete restrict not null,
  step_id bigint REFERENCES public.steps on delete restrict not null,
  text text default null,
  unique (verse_id, step_id)
);
-- authorize with role-based access control (RBAC)
-- https://supabase.com/docs/reference/javascript/rpc
create function public.authorize(
  requested_permission app_permission,
  user_id uuid
) returns boolean language plpgsql security definer as $$
declare bind_permissions int;
begin
select count(*)
from public.role_permissions
  inner join public.user_roles on role_permissions.role = user_roles.role
where role_permissions.permission = authorize.requested_permission
  and user_roles.user_id = authorize.user_id into bind_permissions;
return bind_permissions > 0;
end;
$$;
-- if user can work with site
create function public.has_access(user_id uuid) returns boolean language plpgsql security definer as $$
declare access int;
begin
select count(*)
from public.users
where users.id = has_access.user_id
  AND users.agreement = true
  AND users.confession = true into access;
return access > 0;
end;
$$;
-- Редактировать привилегии может координатор и администратор.
-- Координатор может поменять роль на переводчика или модератора.
-- Админ может на координатора, переводчика или модератора.
create function public.can_change_role(role app_role, from_user uuid, to_user uuid) returns boolean language plpgsql security definer as $$
declare from_user_role app_role;
-- admin
to_user_role app_role;
-- moderator
begin
SELECT role
FROM user_roles
WHERE user_roles.user_id = can_change_role.from_user INTO from_user_role;
SELECT role
FROM user_roles
WHERE user_id = can_change_role.to_user INTO to_user_role;
CASE
  WHEN role = "admin" THEN RETURN false;
WHEN role = "coordinator" THEN IF from_user = "admin"
AND to_user NOT IN ('admin', 'coordinator') THEN RETURN true;
ELSE RETURN false;
END IF;
WHEN role = "moderator" THEN IF from_user = "admin"
AND to_user NOT IN ('admin', 'moderator') THEN RETURN true;
ELSE IF from_user = "coordinator"
AND to_user = 'translator' THEN RETURN true;
ELSE RETURN false;
END IF;
END CASE
;
end;
$$;
-- Secure the tables
-- Secure users
alter table public.users enable row level security;
create policy "Залогиненый юзер может получить список всех юзеров" on public.users for
select using (auth.role() = 'authenticated');
create policy "Создавать может только записи про себя" on public.users for
insert with check (auth.uid() = id);
create policy "Обновлять может только самого себя" on public.users for
update using (auth.uid() = id);
-- Secure languages
alter table public.languages enable row level security;
create policy "Залогиненый юзер может получить список всех языков" on public.languages for
select using (auth.role() = 'authenticated');
create policy "Создавать может только тот, у кого есть привилегия" on public.languages for
insert with check (authorize('languages', auth.uid()));
create policy "Обновлять может только тот, у кого есть привилегия" on public.languages for
update using (authorize('languages', auth.uid()));
create policy "Удалять может только тот, у кого есть привилегия" on public.languages for delete using (authorize('languages', auth.uid()));
-- Secure user_roles
alter table public.user_roles enable row level security;
create policy "Залогиненый юзер может получить список всех ролей любого пользователя" on public.user_roles for
select using (auth.role() = 'authenticated');
create policy "Редактировать привилегии может координатор и администратор. Координатор может поменять роль на переводчика или модератора. Админ может на координатора, переводчика или модератора." on public.user_roles for
update using (authorize('coordinator.set', auth.uid()));
+ -- Secure role_permissions
alter table public.role_permissions enable row level security;
-- Secure methods
alter table public.methods enable row level security;
create policy "Allow everyone read access" on public.methods for
select using (auth.role() = 'authenticated');
create policy "Обновлять может только самого себя" on public.methods for
insert with check (authorize('methods', auth.uid()));
create policy "Allow individual update access" on public.methods for
update using (authorize('methods', auth.uid()));
create policy "Allow individual delete access" on public.methods for delete using (authorize('methods', auth.uid()));
-- Secure projects
alter table public.projects enable row level security;
create policy "Allow everyone read access" on public.languages for
select using (auth.role() = 'authenticated');
create policy "Обновлять может только самого себя" on public.languages for
insert with check (authorize('languages', auth.uid()));
create policy "Allow individual update access" on public.languages for
update using (authorize('languages', auth.uid()));
create policy "Allow individual delete access" on public.languages for delete using (authorize('languages', auth.uid()));
-- Secure project_coordinators
alter table public.project_coordinators enable row level security;
create policy "Allow everyone read access" on public.languages for
select using (auth.role() = 'authenticated');
create policy "Обновлять может только самого себя" on public.languages for
insert with check (authorize('languages', auth.uid()));
create policy "Allow individual update access" on public.languages for
update using (authorize('languages', auth.uid()));
create policy "Allow individual delete access" on public.languages for delete using (authorize('languages', auth.uid()));
-- Secure project_moderators
alter table public.project_moderators enable row level security;
create policy "Allow everyone read access" on public.languages for
select using (auth.role() = 'authenticated');
create policy "Обновлять может только самого себя" on public.languages for
insert with check (authorize('languages', auth.uid()));
create policy "Allow individual update access" on public.languages for
update using (authorize('languages', auth.uid()));
create policy "Allow individual delete access" on public.languages for delete using (authorize('languages', auth.uid()));
-- Secure project_translators
alter table public.project_translators enable row level security;
create policy "Allow everyone read access" on public.languages for
select using (auth.role() = 'authenticated');
create policy "Обновлять может только самого себя" on public.languages for
insert with check (authorize('languages', auth.uid()));
create policy "Allow individual update access" on public.languages for
update using (authorize('languages', auth.uid()));
create policy "Allow individual delete access" on public.languages for delete using (authorize('languages', auth.uid()));
-- Secure briefs
alter table public.briefs enable row level security;
create policy "Allow everyone read access" on public.languages for
select using (auth.role() = 'authenticated');
create policy "Обновлять может только самого себя" on public.languages for
insert with check (authorize('languages', auth.uid()));
create policy "Allow individual update access" on public.languages for
update using (authorize('languages', auth.uid()));
create policy "Allow individual delete access" on public.languages for delete using (authorize('languages', auth.uid()));
-- Secure steps
alter table public.steps enable row level security;
create policy "Allow everyone read access" on public.languages for
select using (auth.role() = 'authenticated');
create policy "Обновлять может только самого себя" on public.languages for
insert with check (authorize('languages', auth.uid()));
create policy "Allow individual update access" on public.languages for
update using (authorize('languages', auth.uid()));
create policy "Allow individual delete access" on public.languages for delete using (authorize('languages', auth.uid()));
-- Secure books
alter table public.books enable row level security;
create policy "Allow everyone read access" on public.languages for
select using (auth.role() = 'authenticated');
create policy "Обновлять может только самого себя" on public.languages for
insert with check (authorize('languages', auth.uid()));
create policy "Allow individual update access" on public.languages for
update using (authorize('languages', auth.uid()));
create policy "Allow individual delete access" on public.languages for delete using (authorize('languages', auth.uid()));
-- Secure chapters
alter table public.chapters enable row level security;
create policy "Allow everyone read access" on public.languages for
select using (auth.role() = 'authenticated');
create policy "Обновлять может только самого себя" on public.languages for
insert with check (authorize('languages', auth.uid()));
create policy "Allow individual update access" on public.languages for
update using (authorize('languages', auth.uid()));
create policy "Allow individual delete access" on public.languages for delete using (authorize('languages', auth.uid()));
-- Secure verses
alter table public.verses enable row level security;
create policy "Allow everyone read access" on public.languages for
select using (auth.role() = 'authenticated');
create policy "Обновлять может только самого себя" on public.languages for
insert with check (authorize('languages', auth.uid()));
create policy "Allow individual update access" on public.languages for
update using (authorize('languages', auth.uid()));
create policy "Allow individual delete access" on public.languages for delete using (authorize('languages', auth.uid()));
-- Secure progress
alter table public.progress enable row level security;
create policy "Allow everyone read access" on public.languages for
select using (auth.role() = 'authenticated');
create policy "Обновлять может только самого себя" on public.languages for
insert with check (authorize('languages', auth.uid()));
create policy "Allow individual update access" on public.languages for
update using (authorize('languages', auth.uid()));
create policy "Allow individual delete access" on public.languages for delete using (authorize('languages', auth.uid()));
-- Send "previous data" on change
alter table public.users replica identity full;
alter table public.languages replica identity full;
-- inserts a row into public.users and assigns roles
create function public.handle_new_user() returns trigger language plpgsql security definer as $$ -- declare is_admin boolean;
begin
insert into public.users (id, email)
values (new.id, new.email);
insert into public.user_roles (user_id, role)
values (new.id, 'translator');
return new;
end;
$$;
-- trigger the function every time a user is created
create trigger on_auth_user_created
after
insert on auth.users for each row execute procedure public.handle_new_user();
/**
 * REALTIME SUBSCRIPTIONS
 * Only allow realtime listening on public tables.
 */
begin;
-- remove the realtime publication
drop publication if exists supabase_realtime;
-- re-create the publication but don't enable it for any tables
create publication supabase_realtime;
commit;
-- add tables to the publication
alter publication supabase_realtime
add table public.languages;
alter publication supabase_realtime
add table public.users;
-- DUMMY DATA
insert into public.languages (eng, code, orig_name)
values ('russian', 'ru', 'русский'),
  ('english', 'en', 'english');
insert into public.role_permissions (role, permission)
values ('moderator', 'dictionaries'),
  ('moderator', 'notes'),
  ('coordinator', 'dictionaries'),
  ('coordinator', 'notes'),
  ('coordinator', 'verses.set'),
  ('coordinator', 'moderator.set'),
  ('coordinator', 'user_projects'),
  ('admin', 'dictionaries'),
  ('admin', 'notes'),
  ('admin', 'verses.set'),
  ('admin', 'moderator.set'),
  ('admin', 'user_projects'),
  ('admin', 'projects'),
  ('admin', 'project_source'),
  ('admin', 'coordinator.set'),
  ('admin', 'languages'),
  ('admin', 'user_languages');