-- This script was generated by the Schema Diff utility in pgAdmin 4
-- For the circular dependencies, the order in which Schema Diff writes the objects is not very sophisticated
-- and may require manual changes to the script to ensure changes are applied in the correct order.
-- Please report an issue for any failure with the reproduction steps.

CREATE OR REPLACE FUNCTION public.authorize(
	requested_permission app_permission,
	user_id uuid)
    RETURNS boolean
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE SECURITY DEFINER PARALLEL UNSAFE
AS $BODY$
DECLARE
  bind_permissions INT;

BEGIN
  SELECT
    COUNT(*)
  FROM
    PUBLIC .role_permissions
    INNER JOIN PUBLIC .project_roles ON role_permissions.role = project_roles.role
  WHERE
    role_permissions.permission = authorize.requested_permission
    AND project_roles.user_id = authorize.user_id INTO bind_permissions;

RETURN bind_permissions > 0;

END;

$BODY$;

ALTER FUNCTION public.authorize(app_permission, uuid)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.authorize(app_permission, uuid) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.authorize(app_permission, uuid) TO anon;

GRANT EXECUTE ON FUNCTION public.authorize(app_permission, uuid) TO authenticated;

GRANT EXECUTE ON FUNCTION public.authorize(app_permission, uuid) TO postgres;

GRANT EXECUTE ON FUNCTION public.authorize(app_permission, uuid) TO service_role;

CREATE OR REPLACE FUNCTION public.can_change_role(
	role project_role,
	from_user uuid,
	to_user uuid)
    RETURNS boolean
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE SECURITY DEFINER PARALLEL UNSAFE
AS $BODY$
DECLARE
  from_user_role project_role;

to_user_role project_role;

BEGIN
  SELECT
    project_roles.role
  FROM
    project_roles
  WHERE
    project_roles.user_id = can_change_role.from_user INTO from_user_role;

SELECT
  project_roles.role
FROM
  project_roles
WHERE
  project_roles.user_id = can_change_role.to_user INTO to_user_role;

IF can_change_role.role = 'moderator'
AND from_user_role = 'coordinator'
AND to_user_role = 'translator' THEN RETURN TRUE;

END IF;

IF can_change_role.role = 'translator'
AND from_user_role = 'coordinator'
AND to_user_role = 'moderator' THEN RETURN TRUE;

END IF;

RETURN FALSE;

END;

$BODY$;

ALTER FUNCTION public.can_change_role(project_role, uuid, uuid)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.can_change_role(project_role, uuid, uuid) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.can_change_role(project_role, uuid, uuid) TO anon;

GRANT EXECUTE ON FUNCTION public.can_change_role(project_role, uuid, uuid) TO authenticated;

GRANT EXECUTE ON FUNCTION public.can_change_role(project_role, uuid, uuid) TO postgres;

GRANT EXECUTE ON FUNCTION public.can_change_role(project_role, uuid, uuid) TO service_role;

CREATE OR REPLACE FUNCTION public.has_access(
	user_id uuid)
    RETURNS boolean
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE SECURITY DEFINER PARALLEL UNSAFE
AS $BODY$
DECLARE
  access INT;

BEGIN
  SELECT
    COUNT(*)
  FROM
    PUBLIC .users
  WHERE
    users.id = has_access.user_id
    AND users.agreement = TRUE
    AND users.confession = TRUE INTO access;

RETURN access > 0;

END;

$BODY$;

ALTER FUNCTION public.has_access(uuid)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.has_access(uuid) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.has_access(uuid) TO anon;

GRANT EXECUTE ON FUNCTION public.has_access(uuid) TO authenticated;

GRANT EXECUTE ON FUNCTION public.has_access(uuid) TO postgres;

GRANT EXECUTE ON FUNCTION public.has_access(uuid) TO service_role;

CREATE OR REPLACE FUNCTION public.handle_new_project()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF SECURITY DEFINER
AS $BODY$
 BEGIN
  INSERT INTO
    PUBLIC .briefs (project_id)
  VALUES
    (NEW .id);

RETURN NEW;

END;

$BODY$;

ALTER FUNCTION public.handle_new_project()
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.handle_new_project() TO authenticated;

GRANT EXECUTE ON FUNCTION public.handle_new_project() TO postgres;

GRANT EXECUTE ON FUNCTION public.handle_new_project() TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.handle_new_project() TO anon;

GRANT EXECUTE ON FUNCTION public.handle_new_project() TO service_role;

CREATE OR REPLACE FUNCTION public.handle_new_user()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF SECURITY DEFINER
AS $BODY$
 BEGIN
  INSERT INTO
    PUBLIC .users (id, email, login)
  VALUES
    (NEW .id, NEW .email, NEW .raw_user_meta_data ->> 'login');

RETURN NEW;

END;

$BODY$;

ALTER FUNCTION public.handle_new_user()
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.handle_new_user() TO authenticated;

GRANT EXECUTE ON FUNCTION public.handle_new_user() TO postgres;

GRANT EXECUTE ON FUNCTION public.handle_new_user() TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.handle_new_user() TO anon;

GRANT EXECUTE ON FUNCTION public.handle_new_user() TO service_role;

CREATE TABLE IF NOT EXISTS public.verses
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    num smallint NOT NULL,
    chapter_id bigint NOT NULL,
    project_translator_id bigint,
    text text COLLATE pg_catalog."default",
    CONSTRAINT verses_pkey PRIMARY KEY (id),
    CONSTRAINT verses_chapter_id_num_key UNIQUE (chapter_id, num),
    CONSTRAINT verses_chapter_id_fkey FOREIGN KEY (chapter_id)
        REFERENCES public.chapters (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE,
    CONSTRAINT verses_project_translator_id_fkey FOREIGN KEY (project_translator_id)
        REFERENCES public.project_translators (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.verses
    OWNER to postgres;

GRANT ALL ON TABLE public.verses TO authenticated;

GRANT ALL ON TABLE public.verses TO anon;

GRANT ALL ON TABLE public.verses TO service_role;

GRANT ALL ON TABLE public.verses TO postgres;

COMMENT ON COLUMN public.verses.text
    IS 'тут будет храниться последний текст. Когда мы переходим на следующий шаг, мы копируем текст и номер предыдущего шага';

CREATE TABLE IF NOT EXISTS public.project_translators
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    project_id bigint NOT NULL,
    user_id uuid NOT NULL,
    is_moderator boolean DEFAULT false,
    CONSTRAINT project_roles_pkey PRIMARY KEY (id),
    CONSTRAINT project_translators_project_id_fkey FOREIGN KEY (project_id)
        REFERENCES public.projects (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT project_translators_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES public.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.project_translators
    OWNER to postgres;

ALTER TABLE IF EXISTS public.project_translators
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.project_translators TO authenticated;

GRANT ALL ON TABLE public.project_translators TO anon;

GRANT ALL ON TABLE public.project_translators TO service_role;

GRANT ALL ON TABLE public.project_translators TO postgres;
CREATE POLICY "Залогиненый юзер может получить с"
    ON public.project_translators
    AS PERMISSIVE
    FOR SELECT
    TO authenticated
    USING (true);

CREATE TABLE IF NOT EXISTS public.projects
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    title text COLLATE pg_catalog."default" NOT NULL,
    code text COLLATE pg_catalog."default" NOT NULL,
    language_id bigint NOT NULL,
    type project_type NOT NULL,
    resources json,
    method text COLLATE pg_catalog."default",
    base_manifest json,
    CONSTRAINT projects_pkey PRIMARY KEY (id),
    CONSTRAINT projects_code_language_id_key UNIQUE (code, language_id),
    CONSTRAINT projects_language_id_fkey FOREIGN KEY (language_id)
        REFERENCES public.languages (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.projects
    OWNER to postgres;

GRANT ALL ON TABLE public.projects TO authenticated;

GRANT ALL ON TABLE public.projects TO anon;

GRANT ALL ON TABLE public.projects TO service_role;

GRANT ALL ON TABLE public.projects TO postgres;

COMMENT ON COLUMN public.projects.type
    IS 'копируется с талбицы методов';

COMMENT ON COLUMN public.projects.resources
    IS 'копируем с таблицы методов, должны быть запонены ссылки, указываем овнера, репо, коммит';

COMMENT ON COLUMN public.projects.method
    IS 'копируем без изменений название метода с таблицы шаблонов';

CREATE TRIGGER on_public_project_created
    AFTER INSERT
    ON public.projects
    FOR EACH ROW
    EXECUTE FUNCTION public.handle_new_project();

CREATE TABLE IF NOT EXISTS public.progress
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    verse_id bigint NOT NULL,
    step_id bigint NOT NULL,
    text text COLLATE pg_catalog."default",
    CONSTRAINT progress_pkey PRIMARY KEY (id),
    CONSTRAINT progress_verse_id_step_id_key UNIQUE (verse_id, step_id),
    CONSTRAINT progress_step_id_fkey FOREIGN KEY (step_id)
        REFERENCES public.steps (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE,
    CONSTRAINT progress_verse_id_fkey FOREIGN KEY (verse_id)
        REFERENCES public.verses (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.progress
    OWNER to postgres;

GRANT ALL ON TABLE public.progress TO authenticated;

GRANT ALL ON TABLE public.progress TO anon;

GRANT ALL ON TABLE public.progress TO service_role;

GRANT ALL ON TABLE public.progress TO postgres;

CREATE TABLE IF NOT EXISTS public.project_coordinators
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    user_id uuid,
    created_at timestamp with time zone DEFAULT now(),
    project_id bigint,
    CONSTRAINT project_coordinators_pkey PRIMARY KEY (id),
    CONSTRAINT project_coordinators_project_id_fkey FOREIGN KEY (project_id)
        REFERENCES public.projects (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT project_coordinators_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES public.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.project_coordinators
    OWNER to postgres;

GRANT ALL ON TABLE public.project_coordinators TO anon;

GRANT ALL ON TABLE public.project_coordinators TO authenticated;

GRANT ALL ON TABLE public.project_coordinators TO postgres;

GRANT ALL ON TABLE public.project_coordinators TO service_role;

CREATE TABLE IF NOT EXISTS public.role_permissions
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    role project_role NOT NULL,
    permission app_permission NOT NULL,
    CONSTRAINT role_permissions_pkey PRIMARY KEY (id),
    CONSTRAINT role_permissions_role_permission_key UNIQUE (role, permission)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.role_permissions
    OWNER to postgres;

ALTER TABLE IF EXISTS public.role_permissions
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.role_permissions TO anon;

GRANT ALL ON TABLE public.role_permissions TO authenticated;

GRANT ALL ON TABLE public.role_permissions TO postgres;

GRANT ALL ON TABLE public.role_permissions TO service_role;

COMMENT ON TABLE public.role_permissions
    IS 'Application permissions for each role.';

CREATE TABLE IF NOT EXISTS public.steps
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    title text COLLATE pg_catalog."default" NOT NULL,
    project_id bigint NOT NULL,
    config json NOT NULL,
    order_by smallint NOT NULL,
    description text COLLATE pg_catalog."default",
    intro text COLLATE pg_catalog."default",
    CONSTRAINT steps_pkey PRIMARY KEY (id),
    CONSTRAINT steps_method_id_order_by_key UNIQUE (project_id, order_by),
    CONSTRAINT steps_project_id_fkey FOREIGN KEY (project_id)
        REFERENCES public.projects (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.steps
    OWNER to postgres;

GRANT ALL ON TABLE public.steps TO anon;

GRANT ALL ON TABLE public.steps TO authenticated;

GRANT ALL ON TABLE public.steps TO postgres;

GRANT ALL ON TABLE public.steps TO service_role;

COMMENT ON COLUMN public.steps.order_by
    IS 'это поле юзер не редактирует. Мы его указываем сами.';

CREATE TABLE IF NOT EXISTS public.users
(
    id uuid NOT NULL,
    email text COLLATE pg_catalog."default" NOT NULL,
    login text COLLATE pg_catalog."default" NOT NULL,
    agreement boolean NOT NULL DEFAULT false,
    confession boolean NOT NULL DEFAULT false,
    is_admin boolean NOT NULL DEFAULT false,
    blocked timestamp without time zone,
    CONSTRAINT users_pkey PRIMARY KEY (id),
    CONSTRAINT users_email_key UNIQUE (email),
    CONSTRAINT users_login_key UNIQUE (login)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.users
    OWNER to postgres;

ALTER TABLE IF EXISTS public.users
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.users TO anon;

GRANT ALL ON TABLE public.users TO authenticated;

GRANT ALL ON TABLE public.users TO postgres;

GRANT ALL ON TABLE public.users TO service_role;
CREATE POLICY "Залогиненый юзер может получить с"
    ON public.users
    AS PERMISSIVE
    FOR SELECT
    TO authenticated
    USING (true);
CREATE POLICY "Обновлять может только самого себ"
    ON public.users
    AS PERMISSIVE
    FOR UPDATE
    TO public
    USING ((auth.uid() = id));
CREATE POLICY "Создавать может только записи про "
    ON public.users
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((auth.uid() = id));

CREATE TABLE IF NOT EXISTS public.books
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    code book_code NOT NULL,
    project_id bigint NOT NULL,
    text text COLLATE pg_catalog."default",
    chapters json,
    CONSTRAINT books_pkey PRIMARY KEY (id),
    CONSTRAINT books_project_id_code_key UNIQUE (project_id, code),
    CONSTRAINT books_project_id_fkey FOREIGN KEY (project_id)
        REFERENCES public.projects (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.books
    OWNER to postgres;

GRANT ALL ON TABLE public.books TO anon;

GRANT ALL ON TABLE public.books TO authenticated;

GRANT ALL ON TABLE public.books TO postgres;

GRANT ALL ON TABLE public.books TO service_role;

COMMENT ON TABLE public.books
    IS 'У каждой книги потом прописать ее вес. Рассчитать на основе англ или русских ресурсов (сколько там слов). Подумать о том, что будет если удалить проект. Так как в таблице книги мы хотим хранить текст. Отобразим 66 книг Библии или 1 ОБС. В будущем парсить манифест чтобы отображать книги которые уже готовы. Или в момент когда админ нажмет "Создать книгу" проверить есть ли они, если нет то выдать предупреждение.';

COMMENT ON COLUMN public.books.text
    IS 'Здесь мы будем собирать книгу чтобы не делать много запросов. Возьмем все главы и объединим. Так же тут со временем пропишем вес книги на основе англ или русского ресурса';

CREATE TABLE IF NOT EXISTS public.languages
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    eng text COLLATE pg_catalog."default" NOT NULL,
    code text COLLATE pg_catalog."default" NOT NULL,
    orig_name text COLLATE pg_catalog."default" NOT NULL,
    is_gl boolean NOT NULL DEFAULT false,
    CONSTRAINT languages_pkey PRIMARY KEY (id),
    CONSTRAINT languages_code_key UNIQUE (code)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.languages
    OWNER to postgres;

ALTER TABLE IF EXISTS public.languages
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.languages TO anon;

GRANT ALL ON TABLE public.languages TO authenticated;

GRANT ALL ON TABLE public.languages TO postgres;

GRANT ALL ON TABLE public.languages TO service_role;
CREATE POLICY "Залогиненый юзер может получить с"
    ON public.languages
    AS PERMISSIVE
    FOR SELECT
    TO authenticated
    USING (true);
CREATE POLICY "Обновлять может только тот, у кого "
    ON public.languages
    AS PERMISSIVE
    FOR UPDATE
    TO public
    USING (authorize('languages'::app_permission, auth.uid()));
CREATE POLICY "Создавать может только тот, у кого "
    ON public.languages
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK (authorize('languages'::app_permission, auth.uid()));
CREATE POLICY "Удалять может только тот, у кого ес"
    ON public.languages
    AS PERMISSIVE
    FOR DELETE
    TO public
    USING (authorize('languages'::app_permission, auth.uid()));

CREATE TABLE IF NOT EXISTS public.methods
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    title text COLLATE pg_catalog."default" NOT NULL,
    steps json,
    resources json,
    type project_type NOT NULL DEFAULT 'bible'::project_type,
    CONSTRAINT methods_pkey PRIMARY KEY (id)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.methods
    OWNER to postgres;

GRANT ALL ON TABLE public.methods TO anon;

GRANT ALL ON TABLE public.methods TO authenticated;

GRANT ALL ON TABLE public.methods TO postgres;

GRANT ALL ON TABLE public.methods TO service_role;

CREATE TABLE IF NOT EXISTS public.briefs
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    project_id bigint NOT NULL,
    text text COLLATE pg_catalog."default",
    CONSTRAINT briefs_pkey PRIMARY KEY (id),
    CONSTRAINT briefs_project_id_key UNIQUE (project_id),
    CONSTRAINT briefs_project_id_fkey FOREIGN KEY (project_id)
        REFERENCES public.projects (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.briefs
    OWNER to postgres;

GRANT ALL ON TABLE public.briefs TO anon;

GRANT ALL ON TABLE public.briefs TO authenticated;

GRANT ALL ON TABLE public.briefs TO postgres;

GRANT ALL ON TABLE public.briefs TO service_role;

COMMENT ON COLUMN public.briefs.text
    IS 'бриф пишем в формате маркдаун';

CREATE TABLE IF NOT EXISTS public.chapters
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    num smallint NOT NULL,
    book_id bigint NOT NULL,
    text text COLLATE pg_catalog."default",
    verses integer,
    CONSTRAINT chapters_pkey PRIMARY KEY (id),
    CONSTRAINT chapters_book_id_num_key UNIQUE (book_id, num),
    CONSTRAINT chapters_book_id_fkey FOREIGN KEY (book_id)
        REFERENCES public.books (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.chapters
    OWNER to postgres;

GRANT ALL ON TABLE public.chapters TO anon;

GRANT ALL ON TABLE public.chapters TO authenticated;

GRANT ALL ON TABLE public.chapters TO postgres;

GRANT ALL ON TABLE public.chapters TO service_role;

-- Type: project_role

-- DROP TYPE IF EXISTS public.project_role;

CREATE TYPE public.project_role AS ENUM
    ('coordinator', 'moderator', 'translator');

ALTER TYPE public.project_role
    OWNER TO postgres;

-- Type: book_code

-- DROP TYPE IF EXISTS public.book_code;

CREATE TYPE public.book_code AS ENUM
    ('gen', 'exo', 'lev', 'num', 'deu', 'jos', 'jdg', 'rut', '1sa', '2sa', '1ki', '2ki', '1ch', '2ch', 'ezr', 'neh', 'est', 'job', 'psa', 'pro', 'ecc', 'sng', 'isa', 'jer', 'lam', 'ezk', 'dan', 'hos', 'jol', 'amo', 'oba', 'jon', 'mic', 'nam', 'hab', 'zep', 'hag', 'zec', 'mal', 'mat', 'mrk', 'luk', 'jhn', 'act', 'rom', '1co', '2co', 'gal', 'eph', 'php', 'col', '1th', '2th', '1ti', '2ti', 'tit', 'phm', 'heb', 'jas', '1pe', '2pe', '1jn', '2jn', '3jn', 'jud', 'rev', 'obs');

ALTER TYPE public.book_code
    OWNER TO postgres;

-- Type: app_permission

-- DROP TYPE IF EXISTS public.app_permission;

CREATE TYPE public.app_permission AS ENUM
    ('dictionaries', 'notes', 'projects', 'verses.set', 'moderator.set', 'user_projects', 'project_source', 'coordinator.set', 'languages', 'user_languages', 'translator.set');

ALTER TYPE public.app_permission
    OWNER TO postgres;

-- Type: project_type

-- DROP TYPE IF EXISTS public.project_type;

CREATE TYPE public.project_type AS ENUM
    ('obs', 'bible');

ALTER TYPE public.project_type
    OWNER TO postgres;
